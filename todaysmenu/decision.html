<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>todays menu</title>
  <meta name="viewport" content="width=device-width, user-scalable=no">

  <!-- Link Swiper's CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/css/swiper.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/js/swiper.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Do+Hyeon|Nanum+Gothic+Coding|Nanum+Myeongjo|Cute+Font|Song+Myung|East+Sea+Dokdo|Cinzel|Great+Vibes|ZCOOL+KuaiLe|Dancing+Script|Gaegu|Lobster|Ubuntu|Pacifico&display=swap" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <!-- Demo styles -->
  <style>
    html, body {
      position: relative;
      height: 100%;
    }
    body {
      background: #eee;
      font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
      font-size: 14px;
      color:#000;
      margin: 0;
      padding: 0;
    }
    .swiper-container {
      width: 100%;
      height: 100%;
    }
    .swiper-slide {
      text-align: center;
      font-size: 18px;
      background: #fff;
      /* Center slide text vertically */
      display: -webkit-box;
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
      -webkit-box-pack: center;
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
      -webkit-box-align: center;
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    }
    .card{
        width:90%;
        height:90%;
        border-radius:25px;

        text-align:center;
        line-height:100%;

        /* background-color:#009688; */
        /* color:white; */
    }
    .card-text{
        position:relative;
        top:calc( 50% - 42px );
        
        font-size:42px;
        font-family: 'Gaegu', cursive;
    }
    .card-button{
      position: relative;
      top: calc( 50% - 10px );
      font-size: 22px;
      font-family: 'Gaegu', cursive;
      border: 1px solid #fff;
      border-radius: 15px;
      width: 40%;
      height: 35px;
      margin: auto;
      line-height: 35px;
    }
    .buffered-margin{
        width:100%;
        height:32px;
    }
    .cover{
      width:100%;
      height:100%;
      position: fixed;
      left:0;
      top:0;
      z-index:10;
      /* background-color:#673ab7; */
      color:white;
      text-align: center;
      font-family: 'Great Vibes', cursive;
      background-image: url("http://recipe1.ezmember.co.kr/cache/recipe/2015/05/11/ad97f23dd7958b2c0890c9859d941ece1.jpg");
      background-repeat: no-repeat;
      background-size:cover;
      background-position: center; 
    }
    .cover-title{
      font-size: 42px;
      position: relative;
      top: 20%;
      text-shadow: 4px 3px 0px slategrey;
      font-weight: bolder;
      font-family: 'Cinzel', serif;
    }
    .cover-input{
      position:relative;
      top:26%;
      font-family: 'Gaegu', cursive;
    }
    .cover-input input{
      background-color:inherit;
      border:none;
      border-bottom:1px solid #fff;
      border-radius: 2px;
      width: 120px;
      color:white;
    }
    .cover-input div{
      font-size:20px;
      text-shadow: 0px 0px 7px #fff;
    }
    .cover-input input{
      background-color:rgba(0,0,0,0);
      border:none;
      height:auto;
    }
    .cover-input input::placeholder{
      color:white;
      text-align:center;
      font-size:16px;
    }
    .cover-input-box{
      width: 50%;
      margin-left: 25%;
      border: 1px solid white;
      border-radius: 15px;
      background-color: rgba(0,0,0,0.15);
      font-family: 'Nanum Gothic Coding', monospace;
      padding-top:10px;
      padding-bottom:10px;
    }
    .cover-input-margin{
      width:100%;
      height:25px;
    }
    .cover-button{
      position:relative;
      top:41%;
      font-family: 'Gaegu', cursive;
      font-size:32px;
      border:1px solid #fff;
      width:50%;
      margin:auto;
      border-radius: 15px;
      font-family: 'Nanum Gothic Coding', monospace;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: rgba(0,0,0,0.1);
    }
    .cover-button-next-prev{
      display:inline-block;
    }
    .cover-button-input-box{
      display: inline-block;
      width: calc(100% - 100px );
    }
    .cover-button:hover{
      background-color: white;
      color:#673ab7;
    }
    .bottombar{
      width:100%;
      height:100px;
      position:fixed;
      bottom: -75px;
      z-index:5;
      background-color:#607d8b;
      color:white;
    }
    .bottombar div{
      text-align:center;
      font-family: 'Gaegu', cursive;
      font-size:20px;
    }
    /* font-family: 'Lobster', cursive;
font-family: 'Gaegu', cursive; */
* {
    margin: 0;
    padding: 0;
}

.tree ul {
	padding-top: 20px;
    position: relative;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

.tree li {
    white-space: nowrap;
	float: left;
    text-align: center;
	list-style-type: none;
	position: relative;
	padding: 20px 5px 0 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*We will use ::before and ::after to draw the connectors*/

.tree li::before, .tree li::after{
	content: '';
	position: absolute;
    top: 0;
    right: 50%;
	border-top: 1px solid #ccc;
	width: 50%;
    height: 20px;
}
.tree li::after{
	right: auto;
    left: 50%;
	border-left: 1px solid #ccc;
}

/*We need to remove left-right connectors from elements without
 any siblings*/
.tree li:only-child::after, .tree li:only-child::before {
	display: none;
}

/*Remove space from the top of single children*/
.tree li:only-child{
    padding-top: 0;
}

/*Remove left connector from first child and
 right connector from last child*/
.tree li:first-child::before, .tree li:last-child::after{
	border: 0 none;
}
/*Adding back the vertical connector to the last nodes*/
.tree li:last-child::before{
	border-right: 1px solid #ccc;
	border-radius: 0 5px 0 0;
	-webkit-border-radius: 0 5px 0 0;
	-moz-border-radius: 0 5px 0 0;
}
.tree li:first-child::after{
	border-radius: 5px 0 0 0;
	-webkit-border-radius: 5px 0 0 0;
	-moz-border-radius: 5px 0 0 0;
}

/*Time to add downward connectors from parents*/
.tree ul ul::before{
	content: '';
	position: absolute;
    top: 0;
    left: 50%;
	border-left: 1px solid #ccc;
	width: 0;
    height: 20px;
}

.tree li a{
	border: 1px solid #ccc;
	padding: 5px 10px;
	text-decoration: none;
	color: #666;
	font-family: arial, verdana, tahoma;
	font-size: 11px;
	display: inline-block;
	
	border-radius: 5px;
	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*Time for some hover effects*/
/*We will apply the hover effect the the lineage of the element also*/
.tree li a:hover, .tree li a:hover+ul li a {
	background: #c8e4f8;
    color: #000;
    border: 1px solid #94a0b4;
}
/*Connector styles on hover*/
.tree li a:hover+ul li::after,
.tree li a:hover+ul li::before,
.tree li a:hover+ul::before,
.tree li a:hover+ul ul::before{
	border-color:  #94a0b4;
}

/*Thats all. I hope you enjoyed it.
 Thanks :)*/
  </style>
</head>
<body>
  <div id=cover class=cover>
    <div id=cover-title class=cover-title style="opacity:0;top:17%;">
        Today's Menu<br>
        Decision
    </div>

    <div id=cover-input class=cover-input style="">
      <div id=cover-tag1 class=cover-input-box style="opacity:0;">
        <div class=cover-button-next-prev onclick="prev(0)">◀ </div>
        <div id=feel class=cover-button-input-box >기분</div>
        <div class=cover-button-next-prev onclick="next(0)"> ▶</div>
      </div>
      <!-- <input type=text> -->
      <div class=cover-input-margin></div>
      <div id=cover-tag2 class=cover-input-box  style="opacity:0;">
        <div class=cover-button-next-prev onclick="prev(1)">◀ </div>
        <div id=weather class=cover-button-input-box>날씨</div>
        <div class=cover-button-next-prev onclick="next(1)"> ▶</div>
      </div>
      <!-- <input type=text> -->
      <div class=cover-input-margin></div>
      <div id=cover-tag3 class=cover-input-box  style="opacity:0;">
        <div class=cover-button-next-prev onclick="prev(2)">◀ </div>
        <div id=date class=cover-button-input-box>요일</div>
        <div class=cover-button-next-prev onclick="next(2)"> ▶</div>
      </div>
      <!-- <input type=text> -->
      <div class=cover-input-margin></div>
      <div id=cover-tag4 class=cover-input-box  style="opacity:0;">
        <div class=cover-button-next-prev onclick="prev(3)">◀ </div>
        <div id=gender class=cover-button-input-box>성별</div>
        <div class=cover-button-next-prev onclick="next(3)"> ▶</div>
      </div>
      <!-- <input type=text> -->
    </div>
    <div class=cover-button onclick="anim_cover_fade_out()">
      Start
    </div>

  </div>
  <div id=bottombar class=bottombar style="bottom:-75px;">
    <div onclick="anim_bottombar()">▼</div>
  </div>
  <!-- Swiper -->
  <div class="swiper-container">
    <div class="swiper-wrapper">

    </div>

  </div>

  <!-- Initialize Swiper -->
  <script>
            // 민들레국수,산쪼메,사천성,롯데리아,본죽,고래성,라이스스토리,맘스터치
        // 비,맑음,구름,눈,바람,태풍(0,1,2,3,4,5)
        // 남,여(0,1)
        // 월,화,수,목,금,토,일(0,1,2,3,4,5,6)
        // 좋음, 약간좋음 보통, 나쁨, 약간나쁨 

    const menuName = ["민들레국수","산쪼메","사천성","롯데리아","본죽","고래성","라이스스토리","맘스터치"];
    const weatherName = ["날씨","비","맑음","구름","눈","바람","태풍"];
    
    const genderName = ["성별","남","여"];
    const feelName = ["기분","좋음","약간좋음","보통","나쁨","약간나쁨"];
    const dateName = ["요일","월","화","수","목","금","토","일"];

    var weatherCount = 0;
    var genderCount = 0;
    var feelCount = 0;
    var dateCount = 0;
    
    const next = ( num)=>{
      if( num == 0){
        feelCount++;
        if(feelCount == feelName.length) feelCount--;
        document.getElementById("feel").innerHTML = feelName[feelCount];
      }else if( num == 1){
        weatherCount++;
        if(weatherCount == weatherName.length) weatherCount--;
        document.getElementById("weather").innerHTML = weatherName[weatherCount]; 
      }else if( num == 2){
        dateCount++;
        if(dateCount == dateName.length) dateCount--;
        document.getElementById("date").innerHTML = dateName[dateCount]; 
      }else if( num == 3){
        genderCount++;
        if(genderCount == genderName.length) genderCount--;
        document.getElementById("gender").innerHTML = genderName[genderCount]; 
      }
    }
    const prev = ( num)=>{
      if( num == 0){
        feelCount--;
        if(feelCount == -1) feelCount++;
        document.getElementById("feel").innerHTML = feelName[feelCount];
      }else if( num == 1){
        weatherCount--;
        if(weatherCount == -1) weatherCount++;
        document.getElementById("weather").innerHTML = weatherName[weatherCount]; 
      }else if( num == 2){
        dateCount--;
        if(dateCount == -1) dateCount++;
        document.getElementById("date").innerHTML = dateName[dateCount]; 
      }else if( num == 3){
        genderCount--;
        if(genderCount == -1) genderCount++;
        document.getElementById("gender").innerHTML = genderName[genderCount]; 
      }
    }
    let slideCount = 0;
    const gen_card = (name,color,background,isfirst) => {
        let html;
        if( isfirst == true ){
            html =  `
            <div class="buffered-margin"></div>
            <div class="swiper-slide">
            <div class="card" style="color:${color};background-color:${background};" >
            <div class=card-text >${name}</div>
            <div class=card-button onclick="location.href='./booking.html'" >예약하러가기</div>
                  </div></div>`;
        } else{
            html =  `
            <div class="swiper-slide">
            <div class="card" style="color:${color};background-color:${background};">
            <div class=card-text >${name}</div>
            <div class=card-button  onclick="location.href='./booking.html'">예약하러가기</div>
                  </div></div>`;
        }
        return html;
    }
    const menu = [
        { 
            name:"민들레 국수",
            color:"#ffffff",
            background:"#ffc107"
        },
        { 
            name:"산쪼메", 
            color:"#ffffff",
            background:"#795548"
        },
        { 
            name:"사천성", 
            color:"#ffffff",
            background:"#f44336"
        },
        { 
            name:"롯데리아", 
            color:"#ffffff",
            background:"#ff5722"
        },
        { 
            name:"본죽", 
            color:"#ffffff",
            background:"#4CAF50"
        },
        {
          name:"고래성",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"라이스스토리",
          color:"#ffffff",
          background:"#3f51b5"
        },
        {
          name:"맘스터치",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"밥버거",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"대동국수",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"피자스쿨",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"라라코스트",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"치쿠린",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"김밥천국",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"부대통령",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"한갈비",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"후성식당",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"신촌돈까스",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"교동국수",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"와따국밥",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"군산순대국밥",
          color:"#ffffff",
          background:"#f44336"
        },
        {
          name:"신전떡볶이",
          color:"#ffffff",
          background:"#f44336"
        },
        
    ];


        // 민들레국수,산쪼메,사천성,롯데리아,본죽,고래성,라이스스토리,맘스터치
        // 비,맑음,구름,눈,바람,태풍(0,1,2,3,4,5)
        // 남,여(0,1)
        // 월,화,수,목,금,토,일(0,1,2,3,4,5,6)
        // 좋음, 약간좋음 보통, 나쁨, 약간나쁨 
        // var data = [
    //   ["민들레국수","비","남","월"],
    //   ["산쪼메","맑음","여","화"],
    //   ["사천성","구름","남","수"],
    //   ["롯데리아","바람","남","목"],
    //   ["본죽","바람","여","금"],
    //   ["고래성","비","남","토"],
    //   ["라이스스토리","맑음","여","일"],
    //   ["맘스터치","바람","여","월"],
    // ]
    var data = [
      {name:"민들레국수",emotion:0,weather:0,gender:0,date:0},
      {name:"산쪼메",emotion:1,weather:1,gender:1,date:1},
      {name:"산쪼메",emotion:2,weather:0,gender:0,date:2},
      {name:"산쪼메",emotion:3,weather:2,gender:0,date:3},
      {name:"산쪼메",emotion:4,weather:4,gender:1,date:4},
      {name:"사천성",emotion:1,weather:2,gender:0,date:2},
      {name:"롯데리아",emotion:2,weather:4,gender:0,date:3},
      {name:"본죽",emotion:3,weather:2,gender:1,date:4},
      {name:"고래성",emotion:4,weather:0,gender:0,date:5},
      {name:"라이스스토리",emotion:1,weather:1,gender:1,date:6},
      {name:"맘스터치",emotion:2,weather:4,gender:1,date:0},
      {name:"맘스터치",emotion:3,weather:1,gender:0,date:1},
      {name:"맘스터치",emotion:4,weather:2,gender:1,date:2},
      {name:"밥버거",emotion:1,weather:1,gender:0,date:1},
      {name:"대동국수",emotion:2,weather:0,gender:1,date:2},
      {name:"피자스쿨",emotion:3,weather:4,gender:0,date:3},
      {name:"라라코스트",emotion:4,weather:4,gender:1,date:4},
      {name:"라라코스트",emotion:1,weather:1,gender:0,date:6},
      {name:"치쿠린",emotion:2,weather:3,gender:0,date:5},
      {name:"치쿠린",emotion:3,weather:2,gender:1,date:6},
      {name:"치쿠린",emotion:4,weather:1,gender:0,date:0},
      {name:"치쿠린",emotion:1,weather:0,gender:1,date:1},
      {name:"김밥천국",emotion:2,weather:3,gender:0,date:6},
      {name:"김밥천국",emotion:3,weather:2,gender:1,date:0},
      {name:"부대통령",emotion:4,weather:1,gender:1,date:0},
      {name:"한갈비",emotion:1,weather:1,gender:0,date:1},
      {name:"한갈비",emotion:2,weather:2,gender:1,date:2},
      {name:"한갈비",emotion:3,weather:0,gender:1,date:3},
      {name:"후성식당",emotion:1,weather:1,gender:1,date:2},
      {name:"후성식당",emotion:2,weather:2,gender:0,date:3},
      {name:"후성식당",emotion:3,weather:3,gender:0,date:4},
      {name:"후성식당",emotion:4,weather:4,gender:1,date:6},
      {name:"신촌돈까스",emotion:1,weather:2,gender:1,date:3},
      {name:"신촌돈까스",emotion:2,weather:1,gender:0,date:2},
      {name:"교동국수",emotion:1,weather:0,gender:0,date:4},
      {name:"교동국수",emotion:2,weather:0,gender:1,date:3},
      {name:"와따국밥",emotion:3,weather:0,gender:1,date:5},
      {name:"군산순대국밥",emotion:1,weather:2,gender:0,date:6},
      {name:"군산순대국밥",emotion:2,weather:1,gender:1,date:0},
      {name:"군산순대국밥",emotion:3,weather:0,gender:1,date:1},
      {name:"신전떡볶이",emotion:1,weather:2,gender:1,date:0},
      {name:"신전떡볶이",emotion:2,weather:0,gender:0,date:1},
    ]
  
    const anim_bottombar = ()=>{
      if(document.getElementById("bottombar").style.bottom == "-75px"){
        $("#bottombar").animate({
          bottom: "0px"
        },100,()=>{});
      }else{
        $("#bottombar").animate({
          bottom: "-75px"
        },100,()=>{});
      }
      
    }
    const anim_cover_fade_in = ()=>{
      $("#cover-title").animate({
        opacity:1,
        top:"14%"
      },1000,()=>{
        $("#cover-tag1").animate({
          opacity:1
        },500,()=>{
          $("#cover-tag2").animate({
            opacity:1
          },500,()=>{
            $("#cover-tag3").animate({
              opacity:1
            },500,()=>{
              $("#cover-tag4").animate({
                opacity:1
              },500,()=>{
                
              });
            });
          });
        });
      });
    }
    const anim_cover_fade_out = ()=>{
      // document.getElementById("cover").style.display="None";
      if( feelCount == 0 || weatherCount == 0 || genderCount == 0 || dateCount == 0 ){
        alert("입력이 비어있습니다 ㅠㅠ;");
      }else{
        $("#cover").animate({
          top: window.outerHeight * -1 + "px"
        },1000,()=>{
          let min = 0;
          let max = menu.length;
          
          var config = {
              trainingSet : data,
              categoryAttr : 'name',
              ignoredAttributes : []
            };
          var decisionTree = new dt.DecisionTree(config);
          console.log({feel:feelCount,weather:weatherCount,gender:genderCount,date:dateCount});
          var decisionTreePrediction = decisionTree.predict(
            {feel:feelCount,weather:weatherCount,gender:genderCount,date:dateCount});
          alert(decisionTreePrediction);
          for(var i=0;i<menu.length;i++){
            if(menu[i].name == decisionTreePrediction){
              anim_random_slide( i );
            }
              
          }
          // anim_random_slide( Math.floor(Math.random() * (max - min)) + min );
        });
      }
    

    }
    var swiper = new Swiper('.swiper-container', {
        direction: 'vertical',

    });
    const anim_random_slide = (indexNo)=>{
      setTimeout(()=>{
        let min = 0;
        let max = menu.length;
        let slideNo = Math.floor(Math.random() * (max - min)) + min;  
        swiper.slideTo(slideNo,80);
      },100);
      setTimeout(()=>{
        let min = 0;
        let max = menu.length;
        let slideNo = Math.floor(Math.random() * (max - min)) + min;  
        swiper.slideTo(slideNo,80);
      },200);
      setTimeout(()=>{
        let min = 0;
        let max = menu.length;
        let slideNo = Math.floor(Math.random() * (max - min)) + min;  
        swiper.slideTo(slideNo,80);
      },300);
      setTimeout(()=>{
        let min = 0;
        let max = menu.length;
        let slideNo = Math.floor(Math.random() * (max - min)) + min;  
        swiper.slideTo(slideNo,80);
      },400);
      setTimeout(()=>{
        let min = 0;
        let max = menu.length;
        let slideNo = Math.floor(Math.random() * (max - min)) + min;  
        swiper.slideTo(slideNo,80);
      },500);
      setTimeout(()=>{
        swiper.slideTo(indexNo,80);
      },600);
    }


    window.onload= ()=>{

      anim_cover_fade_in();

      const container = document.getElementById("container");
      var isfirst = false;
      for(var i=0;i<menu.length;i++){
          if( i == 0 ) isfirst = false;
          else isfirst = true;

          console.log(menu[i]);
          swiper.addSlide(slideCount++,gen_card( menu[i].name, menu[i].color,menu[i].background,isfirst));
      }
      
      menuIndex = null;

      // 랜덤.
      menuIndex = Math.floor(Math.random() * menu.length ); 
      // 디시젼 트리.
      
      // var decisionTreePrediction = decisionTree.predict({weather:0,gender:0,date:2});
      // console.log(decisionTreePrediction)
      // document.getElementById('tree').innerHTML = treeToHtml(decisionTree.root);
      // 신경망 학습.
      
      // anim_random_slide(menuIndex);

    }
    function treeToHtml(tree) {
    // only leafs containing category
    if (tree.category) {
        return  ['<ul>',
                    '<li>',
                        '<a href="#">',
                            '<b>', tree.category, '</b>',
                        '</a>',
                    '</li>',
                 '</ul>'].join('');
    }
    
    return  ['<ul>',
                '<li>',
                    '<a href="#">',
                        '<b>', tree.attribute, ' ', tree.predicateName, ' ', tree.pivot, ' ?</b>',
                    '</a>',
                    '<ul>',
                        '<li>',
                            '<a href="#">yes</a>',
                            treeToHtml(tree.match),
                        '</li>',
                        '<li>', 
                            '<a href="#">no</a>',
                            treeToHtml(tree.notMatch),
                        '</li>',
                    '</ul>',
                '</li>',
             '</ul>'].join('');
}
    var dt = (function () {
          
          /**
           * Creates an instance of DecisionTree
           *
           * @constructor
           * @param builder - contains training set and
           *                  some configuration parameters
           */
          function DecisionTree(builder) {        
              this.root = buildDecisionTree({
                  trainingSet: builder.trainingSet,
                  ignoredAttributes: arrayToHashSet(builder.ignoredAttributes),
                  categoryAttr: builder.categoryAttr || 'category',
                  minItemsCount: builder.minItemsCount || 1,
                  entropyThrehold: builder.entropyThrehold || 0.01,
                  maxTreeDepth: builder.maxTreeDepth || 70
              });
          }
                
          DecisionTree.prototype.predict = function (item) {
              return predict(this.root, item);
          }
      
          /**
           * Creates an instance of RandomForest
           * with specific number of trees
           *
           * @constructor
           * @param builder - contains training set and some
           *                  configuration parameters for
           *                  building decision trees
           */
          function RandomForest(builder, treesNumber) {
              this.trees = buildRandomForest(builder, treesNumber);
          }
                
          RandomForest.prototype.predict = function (item) {
              return predictRandomForest(this.trees, item);
          }
          
          /**
           * Transforming array to object with such attributes 
           * as elements of array (afterwards it can be used as HashSet)
           */
          function arrayToHashSet(array) {
              var hashSet = {};
              if (array) {
                  for(var i in array) {
                      var attr = array[i];
                      hashSet[attr] = true;
                  }
              }
              return hashSet;
          }
          
          /**
           * Calculating how many objects have the same 
           * values of specific attribute.
           *
           * @param items - array of objects
           *
           * @param attr  - variable with name of attribute, 
           *                which embedded in each object
           */
          function countUniqueValues(items, attr) {
              var counter = {};
      
              // detecting different values of attribute
              for (var i = items.length - 1; i >= 0; i--) {
                  // items[i][attr] - value of attribute
                  counter[items[i][attr]] = 0;
              }
                
              // counting number of occurrences of each of values
              // of attribute
              for (var i = items.length - 1; i >= 0; i--) {
                  counter[items[i][attr]] += 1;
              }
      
              return counter;
          }
          
          /**
           * Calculating entropy of array of objects 
           * by specific attribute.
           *
           * @param items - array of objects
           *
           * @param attr  - variable with name of attribute, 
           *                which embedded in each object
           */
          function entropy(items, attr) {
              // counting number of occurrences of each of values
              // of attribute
              var counter = countUniqueValues(items, attr);
      
              var entropy = 0;
              var p;
              for (var i in counter) {
                  p = counter[i] / items.length;
                  entropy += -p * Math.log(p);
              }
      
              return entropy;
          }
                
          /**
           * Splitting array of objects by value of specific attribute, 
           * using specific predicate and pivot.
           *
           * Items which matched by predicate will be copied to 
           * the new array called 'match', and the rest of the items 
           * will be copied to array with name 'notMatch'
           *
           * @param items - array of objects
           *
           * @param attr  - variable with name of attribute,
           *                which embedded in each object
           *
           * @param predicate - function(x, y) 
           *                    which returns 'true' or 'false'
           *
           * @param pivot - used as the second argument when 
           *                calling predicate function:
           *                e.g. predicate(item[attr], pivot)
           */
          function split(items, attr, predicate, pivot) {
              var match = [];
              var notMatch = [];
      
              var item,
                  attrValue;
                
              for (var i = items.length - 1; i >= 0; i--) {
                  item = items[i];
                  attrValue = item[attr];
      
                  if (predicate(attrValue, pivot)) {
                      match.push(item);
                  } else {
                      notMatch.push(item);
                  }
              };
      
              return {
                  match: match,
                  notMatch: notMatch
              };
          }
      
          /**
           * Finding value of specific attribute which is most frequent
           * in given array of objects.
           *
           * @param items - array of objects
           *
           * @param attr  - variable with name of attribute, 
           *                which embedded in each object
           */
          function mostFrequentValue(items, attr) {
              // counting number of occurrences of each of values
              // of attribute
              var counter = countUniqueValues(items, attr);
      
              var mostFrequentCount = 0;
              var mostFrequentValue;
      
              for (var value in counter) {
                  if (counter[value] > mostFrequentCount) {
                      mostFrequentCount = counter[value];
                      mostFrequentValue = value;
                  }
              };
      
              return mostFrequentValue;
          }
                
          var predicates = {
              '==': function (a, b) { return a == b },
              '>=': function (a, b) { return a >= b }
          };
      
          /**
           * Function for building decision tree
           */
          function buildDecisionTree(builder) {
      
              var trainingSet = builder.trainingSet;
              var minItemsCount = builder.minItemsCount;
              var categoryAttr = builder.categoryAttr;
              var entropyThrehold = builder.entropyThrehold;
              var maxTreeDepth = builder.maxTreeDepth;
              var ignoredAttributes = builder.ignoredAttributes;
      
              if ((maxTreeDepth == 0) || (trainingSet.length <= minItemsCount)) {
                  // restriction by maximal depth of tree
                  // or size of training set is to small
                  // so we have to terminate process of building tree
                  return {
                      category: mostFrequentValue(trainingSet, categoryAttr)
                  };
              }
      
              var initialEntropy = entropy(trainingSet, categoryAttr);
      
              if (initialEntropy <= entropyThrehold) {
                  // entropy of training set too small
                  // (it means that training set is almost homogeneous),
                  // so we have to terminate process of building tree
                  return {
                      category: mostFrequentValue(trainingSet, categoryAttr)
                  };
              }
      
              // used as hash-set for avoiding the checking of split by rules
              // with the same 'attribute-predicate-pivot' more than once
              var alreadyChecked = {};
                
              // this variable expected to contain rule, which splits training set
              // into subsets with smaller values of entropy (produces informational gain)
              var bestSplit = {gain: 0};
      
              for (var i = trainingSet.length - 1; i >= 0; i--) {
                  var item = trainingSet[i];
      
                  // iterating over all attributes of item
                  for (var attr in item) {
                      if ((attr == categoryAttr) || ignoredAttributes[attr]) {
                          continue;
                      }
      
                      // let the value of current attribute be the pivot
                      var pivot = item[attr];
      
                      // pick the predicate
                      // depending on the type of the attribute value
                      var predicateName;
                      if (typeof pivot == 'number') {
                          predicateName = '>=';
                      } else {
                          // there is no sense to compare non-numeric attributes
                          // so we will check only equality of such attributes
                          predicateName = '==';
                      }
      
                      var attrPredPivot = attr + predicateName + pivot;
                      if (alreadyChecked[attrPredPivot]) {
                          // skip such pairs of 'attribute-predicate-pivot',
                          // which been already checked
                          continue;
                      }
                      alreadyChecked[attrPredPivot] = true;
      
                      var predicate = predicates[predicateName];
                
                      // splitting training set by given 'attribute-predicate-value'
                      var currSplit = split(trainingSet, attr, predicate, pivot);
      
                      // calculating entropy of subsets
                      var matchEntropy = entropy(currSplit.match, categoryAttr);
                      var notMatchEntropy = entropy(currSplit.notMatch, categoryAttr);
      
                      // calculating informational gain
                      var newEntropy = 0;
                      newEntropy += matchEntropy * currSplit.match.length;
                      newEntropy += notMatchEntropy * currSplit.notMatch.length;
                      newEntropy /= trainingSet.length;
                      var currGain = initialEntropy - newEntropy;
      
                      if (currGain > bestSplit.gain) {
                          // remember pairs 'attribute-predicate-value'
                          // which provides informational gain
                          bestSplit = currSplit;
                          bestSplit.predicateName = predicateName;
                          bestSplit.predicate = predicate;
                          bestSplit.attribute = attr;
                          bestSplit.pivot = pivot;
                          bestSplit.gain = currGain;
                      }
                  }
              }
      
              if (!bestSplit.gain) {
                  // can't find optimal split
                  return { category: mostFrequentValue(trainingSet, categoryAttr) };
              }
      
              // building subtrees
                
              builder.maxTreeDepth = maxTreeDepth - 1;
      
              builder.trainingSet = bestSplit.match;
              var matchSubTree = buildDecisionTree(builder);
      
              builder.trainingSet = bestSplit.notMatch;
              var notMatchSubTree = buildDecisionTree(builder);
      
              return {
                  attribute: bestSplit.attribute,
                  predicate: bestSplit.predicate,
                  predicateName: bestSplit.predicateName,
                  pivot: bestSplit.pivot,
                  match: matchSubTree,
                  notMatch: notMatchSubTree,
                  matchedCount: bestSplit.match.length,
                  notMatchedCount: bestSplit.notMatch.length
              };
          }
      
          /**
           * Classifying item, using decision tree
           */
          function predict(tree, item) {
              var attr,
                  value,
                  predicate,
                  pivot;
              
              // Traversing tree from the root to leaf
              while(true) {
                
                  if (tree.category) {
                      // only leafs contains predicted category
                      return tree.category;
                  }
      
                  attr = tree.attribute;
                  value = item[attr];
      
                  predicate = tree.predicate;
                  pivot = tree.pivot;
                  console.log("3 >= ",attr);
                  // move to one of subtrees
                  if (predicate(value, pivot)) {
                      tree = tree.match;
                  } else {
                      tree = tree.notMatch;
                  }
              }
          }
          /**
           * Classifying item, using decision tree with path
           */
           function predictAndPath(tree, item ,path) {
              var attr,
                  value,
                  predicate,
                  pivot;
              


              // Traversing tree from the root to leaf
              while(true) {
                
                  if (tree.category) {
                      // only leafs contains predicted category
                      return tree.category;
                  }
      
                  attr = tree.attribute;
                  value = item[attr];
      
                  predicate = tree.predicate;
                  pivot = tree.pivot;
                  console.log(item,pivot);
                  // move to one of subtrees
                  if (predicate(value, pivot)) {
                      tree = tree.match;
                  } else {
                      tree = tree.notMatch;
                  }
              }
          }
          /**
           * Building array of decision trees
           */
          function buildRandomForest(builder, treesNumber) {
              var items = builder.trainingSet;
                
              // creating training sets for each tree
              var trainingSets = [];
              for (var t = 0; t < treesNumber; t++) {
                  trainingSets[t] = [];
              }
              for (var i = items.length - 1; i >= 0 ; i--) {
                // assigning items to training sets of each tree
                // using 'round-robin' strategy
                var correspondingTree = i % treesNumber;
                trainingSets[correspondingTree].push(items[i]);
              }
      
              // building decision trees
              var forest = [];
              for (var t = 0; t < treesNumber; t++) {
                  builder.trainingSet = trainingSets[t];
      
                  var tree = new DecisionTree(builder);
                  forest.push(tree);
              }
              return forest;
          }
      
          /**
           * Each of decision tree classifying item
           * ('voting' that item corresponds to some class).
           *
           * This function returns hash, which contains 
           * all classifying results, and number of votes 
           * which were given for each of classifying results
           */
          function predictRandomForest(forest, item) {
              var result = {};
              for (var i in forest) {
                  var tree = forest[i];
                  var prediction = tree.predict(item);
                  result[prediction] = result[prediction] ? result[prediction] + 1 : 1;
              }
              return result;
          }
      
          var exports = {};
          exports.DecisionTree = DecisionTree;
          exports.RandomForest = RandomForest;
          return exports;
      })();
  </script>
</body>
</html>