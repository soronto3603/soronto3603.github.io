---
layout: post
title:  "[알고리즘] 백준 2504"
date:   2018-12-04 5:28:00
categories: c++
---
# 백준 알고리즘 2504 [시간초과]
본 풀이는 시간초과로 실패하였습니다.

> 예제 입력
> (()[[]])([])

> 예제 결과
> 28

본 예제입력을 설명대로 하나씩 괄호를 풀어본다면 다음과 같은 결과를 얻을 수 있다.

> 0회차 ( ( ) [ [ ] ] ) ( [ ] )
> 1회차 ( 2 [ 3 ] ) ( 3 )
> 2회차 ( 2 + 3*3  )  2*3
> 3회차 2*2 + 2*3*3 + 2*3
> 결과 28

말단의 ( ), [ ] 열고 바로 닫는 괄호들만 살아남고 나머지 말단 괄호를 감싸는 괄호들은
곱하기( * )로 전향된다는 점이다.

말단 괄호가 3개가 있으니 마지막에 3개가 남게된다는게 포인트 이다.
3개의 말단 노드에 곱하기 ( * )를 얼만큼 해주는지가 관건이다.

1. 데이터 리스트를 탐색하다가 ( ) { } 인 경우
1.1 전의 괄호를 체크한다 여는괄호 몇개 닫는 괄호 몇개인지
1.2 여는괄호에서 닫는괄호를 뺀 나머지로 계산 ( 몇개의 괄호가 열려 있는지 - 괄호 수만큼 * )

```
#include<iostream>
#include<vector>

using namespace std;

int getPoint(char c){
    // ( ) 이면 2점 아니면 3점 == { }
    return ( c == '(' || c == ')' ) ? 2 : 3; 
}

// 1. 데이터 리스트를 탐색하다가 ( ) { } 인 경우
//  1.1 뒤의 괄호를 체크한다 여는괄호 몇개 닫는 괄호 몇개인지
//  1.2 여는괄호에서 닫는괄호를 뺀 나머지로 계산 ( 몇개의 괄호가 열려 있는지 )


int main(){
    string input;
    cin>>input;

    
    // 0. result=0
    int result = 0;
    for( int i=1; i < input.size() ; i++ ){
        char post_c = input[i-1];
        char cur_c = input[i];
        // 1. 데이터 리스트를 탐색하다가 ( ) { } 인 경우
        if( (post_c == '(' && cur_c == ')') || (post_c == '[' && cur_c == ']') ){
            // cout << "FIND" << i << endl;
            vector<int> v(2,0);
            //  1.1 전의 괄호를 체크한다 여는괄호 몇개 닫는 괄호 몇개인지
            for( int j=i ; j >= 0 ; j--){
                if( input[j] == '(' ) v[0]++;
                else if( input[j] == ')' ) v[0]--;
                else if( input[j] == '[' ) v[1]++;
                else if( input[j] == ']' ) v[1]--;
            }
            // cout << v[0] << ", " << v[1]<<endl;
            //  1.2 여는괄호에서 닫는괄호를 뺀 나머지로 계산 ( 몇개의 괄호가 열려 있는지 )
            int m_r=getPoint(post_c);
            while( v[0] != 0 ){
                m_r*=2;
                v[0]--;
            }
            while( v[1] != 0){
                m_r*=3;
                v[1]--;
            }
            // cout << "[" << m_r << "]" << endl;
            result += m_r;
        }
        
    }
    cout << result;
    
    
    return 0;
}
```

하지만 결과는 Fail 시간초과이다. 

본 코드에서 핵심적으로 잘못된 부분은 말단노드를 발견할때마다 그 노드로부터 처음 노드까지의 개수를 센다는 점이다.
이 중복되어 시간을 소모하는 것이 주된 문제인 것 같다.
구체적으로

>FIND2 => 2번째 인덱스에서 괄호가 열고닫힘을 확인
>1, 0 => 이전의 괄호가 1번타입의 괄호가 1개 2번 타입의 괄호가 0개
>[4] => 부분적 결과는 4
>FIND5 => 5번째 인덱스에서 괄호가 열고닫힘을 확인
>1, 1 => 이전의 괄호가 1번타입 1개 2번 타입 1개 %% 이부분이 문제
>[18]
>FIND10
>1, 0
>[6]
28%

이전에 인덱스 순서대로 괄호가 몇개인지를 세었었으나
후에 새로운 말단 괄호를 찾았을때 다시 처음부터 세는 것이 문제이다. 
다음 포스팅에 DP 로 이전의 계산을 메모라이즈하여 반복 계산을 줄인다면 통과할 것 같다.

* * *

결국 문제를 풀고자하는 집념으로 메모라이즈기법을 적용해서 문제를 풀어봤지만,
문제에서는 올바르지 않은 경우 또한 분류하여 출력하라고 하여,
스택을 이용하여 괄호가 올바른지 체크해야하는 이유가 생겼다.
꼼수로 문제 풀으려다가 얼마나 돌아가는지 ㅠㅠ

밑의 코드는 메모라이즈 기법을 적용한 코드이다.

```
#include<iostream>
#include<vector>
#include<stack>

using namespace std;

int getPoint(char c){
    // ( ) 이면 2점 아니면 3점 == { }
    return ( c == '(' || c == ')' ) ? 2 : 3; 
}

// 1. 데이터 리스트를 탐색하다가 ( ) { } 인 경우
//  1.1 뒤의 괄호를 체크한다 여는괄호 몇개 닫는 괄호 몇개인지
//  1.2 여는괄호에서 닫는괄호를 뺀 나머지로 계산 ( 몇개의 괄호가 열려 있는지 )


int main(){
    string input;
    cin>>input;

    vector< vector<int> > v;
    // cout << input[0] <<", ";
    v.push_back(vector<int>(2,0));
    if( input[0] == '(' ) v[0][0]++;
    else if( input[0] == ')') v[0][0]--;
    else if( input[0] == '[') v[0][1]++;
    else if( input[0] == ']') v[0][1]--;
    // cout << v[0][0] << ", " << v[0][1] << endl;

    // 0. result=0
    int result = 0;
    for( int i=1; i < input.size() ; i++ ){
        char post_c = input[i-1];
        char cur_c = input[i];

        // cout << cur_c << ", ";
        v.push_back(vector<int>(2,0));
        if( cur_c == '(' ){
            v[i][0]=v[i-1][0]+1;
            v[i][1]=v[i-1][1];
        } 
        else if( cur_c == ')'){
            v[i][0]=v[i-1][0]-1;
            v[i][1]=v[i-1][1];
        } 
        else if( cur_c == '['){
            v[i][1]=v[i-1][1]+1;
            v[i][0]=v[i-1][0];
        } 
        else if( cur_c == ']'){
            v[i][1]=v[i-1][1]-1;
            v[i][0]=v[i-1][0];
        } 
        // cout << v[i-1][0] << ", " << v[i-1][1] << " => ";
        // cout << v[i][0] << ", " << v[i][1] << endl;

        // 1. 데이터 리스트를 탐색하다가 ( ) { } 인 경우
        if( (post_c == '(' && cur_c == ')') || (post_c == '[' && cur_c == ']') ){
            // cout << "FIND" << i << endl;
            //  1.1 전의 괄호를 체크한다 여는괄호 몇개 닫는 괄호 몇개인지
            
            // cout << v[i][0] << ", " << v[i][1]<<endl;
            //  1.2 여는괄호에서 닫는괄호를 뺀 나머지로 계산 ( 몇개의 괄호가 열려 있는지 )
            int m_r=getPoint(post_c);
            for(int k=0;k<v[i][0];k++){
                m_r*=2;
            }
            for(int k=0;k<v[i][1];k++){
                m_r*=3;
            }
            // cout << "[" << m_r << "]" << endl;
            result += m_r;
        }
        
    }
    cout << result;
    
    
    return 0;
}
```

다음 (내일) 포스팅에는 성공하자!